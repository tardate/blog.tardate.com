---
layout: post
title: '2013: Time for web development to have its VB3 moment'
date: '2013-01-12T21:41:00.001+08:00'
author: Paul Gallagher
tags:
- Rails
- Deep thoughts
- Development
modified_time: '2013-02-16T00:59:39.485+08:00'
blogger_id: tag:blogger.com,1999:blog-6220586.post-7725312030120731234
blogger_orig_url: http://blog.tardate.com/2013/01/2013-time-for-web-development-to-have.html
---

<span style="font-style:italic;float:right;">(blogarhythm ~ <a href="http://www.youtube.com/watch?v=pHRm2odvW-o">Come Around Again</a> - JET)</span> <br /><br />And that's a compliment!<br /><br />Wow. This year we mark the 20th anniversary of the <a href="http://en.wikipedia.org/wiki/Visual_Basic">Visual Basic 3.0</a> launch way back in 1993.<br /><br />It's easy to forget the pivotal role it played in revolutionizing how we built software. No matter what you think of Microsoft, one can't deny the impact it had at the time. Along with other products such as <a href="http://en.wikipedia.org/wiki/PowerBuilder">PowerBuilder</a> and <a href="http://en.wikipedia.org/wiki/Embarcadero_Delphi">Borland Delphi</a>, we started to see long-promised advances in software development (as pioneered by <a href="http://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>) become mainstream reality:<br /><ul><li>finally, <a href="http://en.wikipedia.org/wiki/Rapid_application_development">Rapid Application Development</a> that really was rapid</li><li>simplicity that put the development of non-trivial applications within the realm of the average computer user. It made simple things simple and complex things possible (to borrow from <a href="http://en.wikiquote.org/wiki/Alan_Kay">Alan Kay</a>)</li><li>development environments that finally did the obvious: want to build a graphical user interface? Then build it graphically (i.e. <a href="http://en.wikipedia.org/wiki/WYSIWYG">WYSIWYG</a>), and build a complete client or client-server app from a single IDE.</li><li>an event-driven programming model that explicitly linked code to the user-facing triggers and views (like buttons and tables)</li><li>perhaps the first mainstream example of a viable software component reuse mechanism (improved and rebranded many times over time: ActiveX, COM, .NET)</li></ul><br />In its day, Visual Basic 3.0 was variously lauded (by non-programmers who could finally make the app they always wanted) and loathed (by IT professionals shocked at the prospect of ceding control to the great unwashed). Interestingly, Visual Basic succeeded *despite* the language (BASIC, probably the most widely derided language of all time. Or perhaps it shares that crown with COBOL). <br /><br />The party didn't last long however, as by the late 90's the internet had fundamentally changed the rules of the game.<br /><br />VB, PowerBuilder and the like suffered from an implicit assumption of a client-server architecture, and were not prepared for a webified world. They didn't (all) disappear of course, with Visual Basic in particular finding a significant role as Microsoft's mainstream server-side language, and it lives on in Visual Studio. Yet it lost it's revolutionary edge, and had to be content to simply fit in as an "also can do in this language" alternative.<br /><br /><h3>Web Development - a case of one step back and one step forward?</h3>You would think that over the past 20 years, web development would have been able to leap far ahead of what was best practice in client-server computing at the time.<br /><br />We have certainly come a long way since then, and many advances in practice and technology have become de rigueur. Here are some examples that would not have been considered normal by any stretch in 1993:<br /><ul><li>Reliance on open standard protocols at every tier: from client to server, server to database and messaging systems</li><li>Global, well-known repositories of shared, reusable code (<a href="https://github.com">Github</a>, <a href="https://rubygems.org/">Rubygems</a> .. and let's not forget grand-daddy <a href="http://www.cpan.org/">CPAN</a>)</li><li>Version control. There is no argument.</li><li>Automated testing tools and continuous integration.</li><li>Open source is mainstream, and even preferred in many contexts.</li></ul><br />Yet it is also salutary to reflect on some of the great innovations we saw back in 1993 that have yet to be re-invented and re-imagined successfully for the web. <br /><br />I am thinking in particular of the radical productivity that was possible with the event-driven, WYSIWYG GUI programming model. It certainly hasn't gone away (take <a href="https://developer.apple.com/technologies/tools/">xcode</a> for example). But why is that not the leading way of building for the web today? After all, the web is graphical and event-driven. A perfect fit one would think.<br /><br />It has perhaps been the very success of the internet, and the rapid unconstrained innovation it has enabled, that has in turn inhibited major advances in web development. <br /><br />Those that have come close (such as Adobe Flash) have ultimately failed primarily because they did not embrace the open standards of the web. And others, like Microsoft Visual Studio and Oracle JDeveloper have remained locked in proprietary silos.<br /><br />On the whole, we still work at levels of abstraction that are no higher, and many times lower, than those embodied by the best tools of 1993. It is, after all, very difficult to build abstractions over a foundation that is in constant flux. And with highly productive languages and frameworks at our disposal (like Ruby/Rails), it makes complete sense for many - myself included - to actively spurn graphical IDEs for the immense flexibility we get in return for working at the coding coalface.<br /><br /><h3>The Tide is Turning</h3>Once the wild west of hackety scripts and rampant browser incompatibilities, the building blocks of the web have been coalescing. HTML5, CSS3 and leading browser rendering engines are more stable, consistent and reliable than ever. Javascript is now considered a serious language, and the community has embraced higher-level APIs like jQuery and RIA frameworks such as <a href="http://emberjs.com/">ember.js</a> and <a href="http://backbonejs.org/">backbone.js</a>. Web design patterns are more widely understood than ever, with kits like <a href="http://twitter.github.com/bootstrap/">bootstrap</a> putting reusable good practice in the hands of novices.<br /><br />On the backend, our technology stacks are mature and battle-tested (<a href="http://en.wikipedia.org/wiki/LAMP_%28software_bundle%29">LAMP</a>, <a href="http://rubyonrails.org/">Rails</a>). And we have an array of cloud-ready, open source solutions for just about every back-end infrastructure need you can imagine: from BigData (<a href="http://hadoop.apache.org/">Hadoop</a>, <a href="http://www.mongodb.org/">MongoDB</a> ..) to messaging (<a href="http://www.rabbitmq.com/">RabbitMQ</a>, <a href="http://www.zeromq.org/">Ã˜MQ</a> ..) and more.<br /><br />My sense is that in the past couple of years we have been edging towards the next leap forward. Our current plateau is now well consolidated. Yet despite efforts such as <a href="http://www.codecademy.com/">codecademy</a> to open up software coding to all, web development remains as complex as ever. To do it well, you really need to master a dizzying array of technologies and standards.<br /><br /><h3>Time for Web Development to Level Up</h3>What does the next level offer? We don't know yet, but I'd suggest the following as some of the critical concerns for next gen web development:<br /><ul><li>a unified development experience: the ability to build a full-stack application as one without the need for large conceptual and technological leaps from presentation, to business logic, to infrastructure concerns.</li><li>implicit support for distributed event handling: a conventional mechanism for events raised on a client or server to be consumed by another client or server.</li><li>event-driven GUI development: draw a web page as you want it to be presented, hook up events and data sources.</li><li>it is mobile: more than just responsive web design. Explicit suport for presenting appropriately on the full range of desktop, tablet and mobile devices</li><li>distributed data synchronisation: whether data is used live on a web page, stored for HTML5 offline, or synchronized with a native mobile application, our tools know how to distribute and synchronize updates.</li><li>(ideally) let's not have to go back to square one and re-invent our immense investments in standard libraries and reusable code (like the extensive collection of <a href="https://rubygems.org/">ruby gems</a>)</li></ul><br />Do we have the perfect solution yet? No. <br /><br />But we are starting to see enticing inklings of what the future may look like. Perhaps one of the most compelling and complete visions is that provided by the <a href="http://www.meteor.com/">meteor</a> project. It is very close.<br /><br />Will meteor streak ahead to gain massive mid-share and traction? Or will an established platform like Rails take another giant step forward? Or is there something else in the wings we don't know about yet?<br /><br />It will be an interesting year. And if the signs are to be trusted, I expect we'll look back on 2013 as a tipping point in web development - its <b>VB3 moment</b>.<br /><br />Do you think we're in for such a radical shift? Or heading in a different direction altogether? Or will inertia simply carry the status quo... I'd love to hear what others think!<br /><br />