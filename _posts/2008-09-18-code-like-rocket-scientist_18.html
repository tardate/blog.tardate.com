---
layout: post
title: Code Like a Rocket Scientist
date: '2008-09-18T03:38:00.004+08:00'
author: Paul Gallagher
tags:
- Deep thoughts
- Methods
modified_time: '2009-02-26T23:54:44.712+08:00'
blogger_id: tag:blogger.com,1999:blog-6220586.post-1163343529180822060
blogger_orig_url: http://blog.tardate.com/2008/09/code-like-rocket-scientist_18.html
---

<table border="0"><tbody><tr><td style="VERTICAL-ALIGN: top"><blockquote class="quote">Do. Or do not. There is no try. -- <a href="http://en.wikipedia.org/wiki/Yoda">Jedi Master Yoda</a></blockquote><br /><a href="http://www.amazon.com/gp/product/0387308768?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0387308768">The Seven Secrets of How to Think Like a Rocket Scientist</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0387308768" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />by Jim Longuski is a great book. It's almost a pattern language for innovation and getting things done. (I reviewed it in a little more detail <a href="http://pratalife.blogspot.com/2008/09/think-like-rocket-scientist.html">here</a>)<br /><br />Longuski's intent is clearly to crystallize some useful patterns from the life of a "rocket scientist" and recommend them for general use. He successfully pulls it off and in a way that doesn't come over as elitist or sycophantic.<br /><br />As a little thought experiment, I was interested to see how one might apply his ideas to the arena of coding or software development. <br /><br />The "seven secrets" actually encompass 50 lessons in all, so this post soon got a bit out of hand! <br /><br />Anyway, this is what I came up with ... so enjoy, and let me know your own thoughts!</td><br /><td style="VERTICAL-ALIGN: top"><iframe src="http://rcm.amazon.com/e/cm?t=itsaprli-20&o=1&p=8&l=as1&asins=0387308768&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><br /></td></tr></tbody></table><br /><br /><h2>1. Dream</h2><br /><h3>Imagine It</h3><br />You'll never achieve what you can't even imagine. That's good general advice for life. When it comes to our software efforts though, how much time do we really spend letting our imaginations run wild before shifting to a convergent thinking mode and start drilling down on <span style="font-weight:bold;">the</span> solution? <br /><br /><h3>Work on the Big Picture</h3><br />Every journey begins with the first step; a cathedral gets built brick by brick. But without the big picture, we are lost with a pile of bricks.<br /><br />Arguably the technology world is <span style="font-style:italic;">too</span> obsessed with the big picture. Think frameworks to end all frameworks, and our constant reinvention of the perfect computing paradigm: client-server to network-computer to EAI and SOA.<br /><br />But perhaps that is a sign that we don't spend <span style="font-weight:bold;">enough</span> time deeply thinking out the big picture and thus we are stuck leapfrogging from one 80% solution to the next. Who is the programming equivalent of Einstein with his <a href="http://en.wikipedia.org/wiki/General_theory_of_relativity">general theory of relativity</a> and lifelong search for a unified theory of everything? Or are we still waiting for that person to be born?   <br /><br /><h3>Aim High</h3><br />It goes without saying that you must aim high in order to achieve great things.<br /><br />In software, I think it's actually rather common to have high goals in terms of functionality. Often our problem is that the goals are found to be too high at the end of the day. Massive scope slash, pulled features and death-marches result. But remember this is the "Dream" stage. If there is a failure, it is not in the dream, it is skipping straight to "Stage 7. Do"!<br /><br />One area where our dreams tend to lack ambition is quality. <a href="http://www.amazon.com/gp/product/0932633439?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0932633439">Peopleware</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0932633439" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> has a lot to say on this subject!<br /><br /><h3>BS!</h3><br />Encouraging a bit of BS is a good way of knocking the stiffness and formality out of the process. Which is what you need if you are looking for creativity, even if your code is "serious stuff".<br /><br />There's also good logic here. When you invent the most outrageous porkers, you are probably using the technique of inversion - you are purposely searching for inspiration outside the nominal constraints of your problem. In other words, the bullshit artist naturally lives outside the box. Which is where you would expect to find the breakthrough idea of course, right? Make sense, or is that just a prime example of good BS itself!?<br /><br /><h3>Brainstorm</h3><br /><br /><h3>Create Desire</h3><br /><br /><h3>Tell a Story</h3><br /><br /><h3>Sleep on It</h3><br />Literally. As in: work on a problem. Go to bed. Wake up in the morning and find the solution is within your grasp.<br /><br />"Sleep on It" is common folklore, but Longuski's own experience lead him to believe it held some truth.<br /><br />In <a href="http://www.amazon.com/gp/product/0979777704?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0979777704">Brain Rules</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0979777704" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />, John Medina presents more fascinating research that demonstrates the effect. Not only are problems more easily solved, but having slept on a problem, you are more likely to make a creative leap to a better solution.<br /><br />Interestingly, Medina's work also demonstrated proved the truth another bit of folklore: the natural orientation of some people to be early birds, and others to be night owls.<br /><br />So in a software development setting, we would be wise to take advantage of this knowledge:<br /><ul><li>If you are trying to crack a hard problem, pulling an all-nighter is a dumb thing to do. Work it, get some sleep, then come back to it in the morning.</li><br /><li>Know who your night owls and early birds are. If you want the worst productivity possible, making night owls struggle in at 7am and early birds work late into the night.</li></ul>  <br /><br /><h3>Think JFK</h3><br />Who is the JFK, the visionary, for your software project? The one person you all turn to, who helps you believe the impossible might actually be possible, and more importantly nurtures the desire to go for it?<br /><br />Not all projects merit "man on the moon" scale leadership of course. But personally, I'm not interested in working on a project that doesn't have a clear goal. And all goals require at least a little vision to be tangible. <br /><br />So whatever the project, its worth thinking about whether you need a 2 foot, 5 foot or 6 foot JFK. And who will that be? <br /><br />Is it you? Are others waiting for you to stoke up the courage to play that role? Carpe diem!<br /><br /><h2>2. Judge</h2><br /><h3>Get Real</h3><br />DeMarco &amp; Lister coined the brilliant term "Management By Hyperbole" in <a href="http://www.amazon.com/gp/product/0932633439?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0932633439">Peopleware</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0932633439" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />. Which I think hits too close to home in many software development shops. Everyone is going to be the next Google, right?<br /><br />But sometimes you just need to get real, toss the crackpot ideas, and get on with it.<br /><br /><h3>Play Games</h3><br />.. and then get back to work please. You are not <a href="http://en.wikipedia.org/wiki/WarGames">Matt Broderick</a>.<br /><br /><h3>Simulate It</h3><br />The tooling in IT is getting to the stage where simulation is a realistic possibility in routine development. Take Oracle's <a href="http://www.dba-oracle.com/t_rat_real_applications_testing.htm">Real Application Testing</a> for example.<br /><br /><h3>Run a Thought Experiment</h3><br />The cheapest prototype of all.<br /><br /><h3>Know Your Limits</h3><br /><blockquote class="quote">I'm an optimist without illusions -- JFK</blockquote><br /><span style="font-style:italic;"><br />Postscript: Michael clued into the fact that this quote is wrong; it should be "<a href="http://www.brainyquote.com/quotes/quotes/j/johnfkenn135391.html">I'm an idealist without illusions</a>". Either I mis-typed or the book is wrong. The sentiment remains however, or we could now quote <a href="http://www.huffingtonpost.com/2009/02/15/obama-on-republicans-im-a_n_167091.html?show_comment_id=20910930">Obama</a> with "I'm An Optimist, Not A Sap" ;-)</span><br /><br /><h3>Weigh Ideas</h3><br /><br /><h2>3. Ask</h2><br /><br /><h3>Ask Dumb Questions</h3><br /><br /><h3>Ask Big Questions</h3><br /><br /><h3>Ask "What If?"</h3><br /><br /><h3>Ask "Animal, Vegetable or Mineral?"</h3><br /><br /><h3>Ask Just One More Question</h3><br /><br /><h2>4. Check</h2><br /><h3>Prove Yourself Wrong</h3><br />This immediately brings testing to mind. Make sure you put on the black hat (in both the <a href="http://en.wikipedia.org/wiki/Hacker_(computing)">hacker</a> and <a href="http://en.wikipedia.org/wiki/Six_Thinking_Hats">deBono</a> sense) when <a href="http://en.wikipedia.org/wiki/Unit_testing">unit testing</a>. Don't just write tests that prove things work, write tests for the failure modes and boundary conditions too. <br /><br />But we know that already, and usually try for some level of rigorous testing. <br /><br />Where we probably need to take this advice more to heart is at the front-end of the process: <span style="font-weight:bold;">requirements, architecture and design</span>.<br /><br />Have you ever seen a new architecture, specification or design get approved with only cursory review? And perhaps reviewed by people who were not really motivated or perhaps even qualified to do a thorough job? <br /><br />I have. And you know who will suffer for it: the brave team charged with implementing and supporting the system.<br /><br />As we play the role of analyst, architect or designer we should make time to do a thorough critique. Try and break what you have conceived. Admittedly, that can be a hard thing to do. So invite a colleague to help you to try and break the design - an invitation not many would refuse! Do it, even if it's not in the project plan.<br /><br /><h3>Inspect for Defects</h3><br />The IT industry has adopted the quality mantra from manufacturing, but unfortunately our adoption is still highly selective.<br /><br />The typical software testing method is akin to classical "quality by inspection".<br />Poke it, prod it, and raise a ticket if it breaks.<br /><br />That's about as advanced as weaving textiles with steam-driven looms.<br /><br />We are seeing more practices that emphasise "quality by design" however, and that's a good thing. For example, the <a href="http://www.extremeprogramming.org/rules/testfirst.html">test-first</a> and <a href="http://en.wikipedia.org/wiki/Test-driven_development">test driven development</a> movements try to help us to assure quality right at the first gate.<br /><br />A big area for improvement seems to be a general focus on addressing systemmic factors in quality. Fix a bug? What about getting to the root cause of why that bug existed in the first place? Simple techniques like <a href="http://en.wikipedia.org/wiki/Five_whys">5 whys</a> can help get us out of a rut.<br /><br /><h3>Have a Backup Plan</h3><br />I learned this lesson good while doing IT support. Desperate users, desperate situations. You soon discover the importance of always knowing how to retrace your steps, and always having a contingency when you are about to do something that could smoke the users' data (or the hardware).<br /><br />When the walls are buring, there's nothing like the confidence that comes from having backup plans well-ingrained as your standard practice. It can mean the difference between cool, calm success and landing a bloated <a href="http://www.yiyinglu.com/sc/illustration">fail whale</a>.<br /><br />It is the same idea I adopt when using source code control. I'm no fan of the school of thought that says only commit at the end of the job. Commits are my breadcrumbs that mark every step, and prevent bad changes from invalidating a whole coding session.<br /><br /><h3>Do a Sanity Test</h3><br />A good technique to apply to the next social-network-crowdsourcing-prosumer-2.0 business plan you see.<br /><br />But equally valuable for more technical work. Prime candidates for a shrewd eye are server sizing, that convoluted custom framework design, and integration architecture.<br /><br /><h3>Check your Arithmetic</h3><br /><br /><h3>Know the Risks</h3><br />Most projects have some form of risk analysis process. Unfortunately, in my experience, most are cursory point-in-time assessments, with a half-hearted consideration of mitigations. You might do just as well getting a tarot reading.<br /><br />Risks are like enemies ... hold them close, and know them well. <br /><br />Thinking back over the recent projects I've managed, I realise that they all have some aspect of the plan that has been specifically arranged because of the understanding of the risks we faced. My three favourites:<br /> <ul><br /> <li>Scheduling specific proof-of-concept activities at the very front of the project to eliminate risks or put mitigations to the test.</li><br /> <li>Including a performance test, whether the client required it or not. (every well-run performance test I have been involved with has identified at least one issue worth fixing. An issue that would otherwise have gone undetected prior to launch)</li><br /> <li>Re-sequence project activities to address high risk activities as soon as possible.</li><br /> </ul><br /><br /><h3>Question Your Assumptions</h3><br /><br /><h2>5. Simplify</h2><br /><h3>Keep It Simple, Stupid</h3><br />Get <a href="http://en.wikipedia.org/wiki/Agile_software_development">agile</a>.<br /><br /><h3>Draw a Picture</h3><br /><br /><h3>Make a Mock-up</h3><br />Rapid prototypes are good. Probably the single biggest reason why <a href="http://en.wikipedia.org/wiki/Visual_Basic">Visual Basic 3</a> rocked the world. Suddenly, anyone could mock-up a working GUI app in no time at all.<br /><br />Now we're seeing some fantastic examples of this same capability for the new internetworked world. <a href="http://www.wavemaker.com/">WaveMaker</a> may be the new PowerBuilder for the web. And <a href="http://heroku.com/">heroku</a> is making Ruby on Rails a hosted no-brainer.<br /><br />It's an interesting co-incidence that the original Visual Basic was derived from a programmable form system, code name Ruby. <br /><br /><h3>Name the Beasts</h3><br /><br /><h3>Look at the Little Picture</h3><br /><br /><h3>Do the Math</h3><br /><br /><h3>Apply Ockam's Razor</h3><br /><br /><h2>6. Optimize</h2><br /><h3>Minimize the Cost</h3><br /><br /><h3>Minimize the Time</h3><br /><br /><h3>Be Mr Spock</h3><br /><br /><h3>Make it Faster, better, Cheaper (but not all three)</h3><br />Isn't the paradox that almost defines the software industry and the bane of the fixed price contract? <br /><br />In fact, classical project management long held that projects are defined by the <a href="http://en.wikipedia.org/wiki/Project_management#The_traditional_triple_constraints">triple constraints</a> of scope, cost, and schedule. What was unsaid of course is that a fourth variable - quality - was assumed to be constant. <br /><br />Which is of course a great joke.<br /><br />But the even bigger joke is that most organizations still tend to behave as if all four variables can be dictated at will. <br /><br />Kent Beck delivered the seminal piece (in the software context) addressing this issue with his rather radical proposal for <a href="http://www.jarn.com/about/OptionalScopeContracts.pdf">Optional Scope Contracts</a>. This is eminently sensible and usually the best reflection of the real objectives on the ground (<span style="font-style:italic;">"we only have this much money to spend on the project; must deliver something within 3 months; and can't compromise on this level of quality. So what we can adjust along the way is: scope!"</span>)<br /><br />This is a key topic covered in the excellent book, <a href="http://www.amazon.com/gp/product/0321278658?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321278658">Extreme Programming Explained</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0321278658" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.<br /> <br /><h3>Know When Bigger is Better</h3><br />We have <a href="http://en.wikipedia.org/wiki/Moore%27s_law">Moore's Law</a> to blame for making this a perennial issue in IT.<br /><br />Our systems comprise hardware and software. In crude terms, we seek the optimal balance between throwing hardware at the problem and choosing the most productive development tools.<br /><br />The most exciting trend we are seeing now of course is the mainstream adoption of dynamic scripting languages (python, ruby and php) in problem domains that were once the exclusive province of "proper" (compiled) languages.<br /><br /><h3>Let Form Follow Function</h3><br />I'll resist making a joke on designers with their iMacs, photoshop and flash.<br /><br />In truth, the leading ideas in graphic/web/interaction design are spot on. Check out Robert Hoekman's <a href="http://www.amazon.com/gp/product/0321535081?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321535081">Designing the Moment</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0321535081" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> for example (highly recommended).<br /><br />But let's talk about coding for a sec. Have you ever spent time polishing code, refactoring, or building a really cool bell or whistle ... before you've got even the most basic features working properly?<br /><br /><a href="http://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a>, and an agile planning method like <a href="http://en.wikipedia.org/wiki/Scrum_(development)">scrum</a> are good anti-dotes for this!<br /><br /><h3>Pick the Best People</h3><br />Fred Brooks highlighted the huge variation in individual programmer productivity in the classic <a href="http://www.amazon.com/gp/product/0201835959?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0201835959">The Mythical Man-Month: Essays on Software Engineering, Anniversary Edition (2nd Edition)</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0201835959" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />.<br /><br />For one of the best treatments of how to work with this reality, <a href="http://www.amazon.com/gp/product/0932633439?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0932633439">Peopleware</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0932633439" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> is the canonical read:<br /><blockquote class="quote">The final outcome of any effort is more a function of <span style="font-style:italic;">who</span> does the work than of <span style="font-style:italic;">how</span> the work is done.<br />..<br /><ul><li>get the right people</li><br /><li>make them happy so they don't want to leave</li><br /><li>turn them loose</li></ul></blockquote><br /><h3>Make Small Improvements</h3><br /><br /><h2>7. Do</h2><br /><h3>Learn by Doing</h3><br />Real programmers know that what the docs say can be a universe away from how things actually work.<br /><br />The only way you get to find this out (and hopefully make it all work) is to roll up your sleeves and do stuff.<br /><br />Similarly, I believe that the only good architect is a <b>practicing architect</b>. If you are not taking every opportunity to work on your craft and keep current, you are ossifying. <br /><br />The non-practicing architect is typically engaging in what I call "retrospective architecture": looking back at what worked in the past, codifying it as an "architecture" and promulgating it as a "standard". That's putting innovation in the deep freeze, and needs to be shunned!<br /><br /><h3>Sharpen Your Axe</h3><br />The best, smartest and most creative developers I know are really lazy. In a good way: work smart, not hard.<br /><br />So while your "good" developer may spend 3 hours cutting and pasting SQL statements around to generate a test date set, the "lazy" developer has whipped up some sql/perl/awk script of Excel sheet that does the same in 5 minutes. <br /><br />They love their tools, keep them good and sharp, and always on the lookout for a new one. Sharp tools make quick work of repetitive grunt work.<br /><br /><h3>Correct It on the Way</h3><br />It is salutary to learn that for the first US planetary mission to Venus, the rocket scientists actually argued about whether course corrections would be needed on the way. Thankfully, to avoid missing Venus by a million miles, trajectory correction maneuvers (TCM) became standard practice. It is of course how "smart" bombs work too.<br /><br />And the same applies to software development. No matter how perfectly you have things planned out, there will always be some unpredictable external influences along the way. If you are not able to respond, then the outcome is no longer under your control.<br /><br />This is a core belief of the agile movement, and enshrined in the <a href="http://agilemanifesto.org/principles.html">agile manifesto</a>.<br /><br /><h3>Do Something</h3><br /><a href="http://www.urbandictionary.com/define.php?term=JFDI">JFDI</a> aka NIKE! <br /><br />Doing software is a natural procrastinator's heaven on earth (or hell, depending on how firm those deadlines are).<br /><br />As a well-practiced procrastinator and perfectionist myself, I've learned that "Do Something" is best advice ever. <br /><br />The strange thing is ... it doesn't matter so much what you do (even to the extent of temporarily switching to another project or task). <span style="font-style:italic;">[this technique is discussed in another book I've read, but I forget the reference for now]</span><br /><br />The important thing is you build some momentum and get moving. The more you do, the more opportunity you will have to explore alternatives and backtrack if necessary.<br /><br /><h3>Don't Ignore Trends</h3><br /><br /><h3>Work on Your Average Performance</h3><br />Software development is well known for its reliance on crash schedules and bucketloads of overtime to get things done.<br /><br />For short periods of time, it may be a necessary and effective course of action to get you out of a desperate hole.<br /><br />But over the course of a year, how does the productivity of such a shop compare with one that is operating at a more steady, controlled pace? <br /><br />More than likely, the shop that just focuses on the bursts of peak performance, has a terrible long term average performance. Not only is average performance out of control because no-one is looking, but it's taking a pummeling from the burnout, turnover and very deep troughs in performance between peaks.<br /> <br />In software development, we should be much more concerned with improving our average performance than maximising our peak. "Situation nominal" as Houston would say. <br /><br /><h3>Look Behind You</h3><br />In software we conventionally think of using project postmortems and knowledge sharing initiatives to capitalise on our history. Everyone pays lip service to this idea, but in my experience few companies effectively practice it.<br /><br />This is especially true in organisations driven by the quarterly numbers. It is easy to understand why: there's an inherent disincentive built into the system. The project is delivered and the value is captured, so a postmortem is just a cost that may not have a return for who knows how long (and you are not even sure who the beneficiary may be).<br /><br />But even if the organisation doesn't see the value, as professionals you would expect we would take the initiative, right? Unfortunately not, because these project-level retrospectives tend not to make a great deal of intuitive sense. Have you ever delivered the same project twice? Isn't technology changing so rapidly that there's more value in learning the new, than tilling the soil of the old?   <br /><br />All these factors conspire to work against our ability to learn from the past at the organisational and individual level. Which is really bizarre when you think about it, given that being successful in the software industry almost demands a focus on continuous learning.<br /><br />Personally, I think we have two powerful weapons at hand to battle this tendency:<br /><ol><li>The <a href="http://en.wikipedia.org/wiki/Software_design_pattern">patterns movement</a>, which allows us to understand generic concepts and package them for reuse. We may never do the same project twice, but we will use the same approaches many times.</li><br /><li>The agile movement, which emphasises incremental effort, and an ever-increasing range of collaborative tools (all that "Web 2.0" stuff). Do your learning and sharing all the time. If you leave it to the end of the project, you already know when it will get done ... never!</li></ol> <br /><br /><h3>Learn From Your Mistakes</h3><br />Never! Or <a href="http://www.amazon.com/gp/product/0387308768?ie=UTF8&tag=itsaprli-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0387308768">get the book</a><img src="http://www.assoc-amazon.com/e/ir?t=itsaprli-20&l=as2&o=1&a=0387308768" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> and you might have a chance.