---
layout: post
title: Software Fortresses
date: '2007-10-07T21:27:00.000+08:00'
author: Paul Gallagher
tags:
- TechRead
- Read
modified_time: '2007-10-07T21:28:54.282+08:00'
blogger_id: tag:blogger.com,1999:blog-18987903.post-6054571799552596886
blogger_orig_url: http://pratalife.blogspot.com/2007/09/software-fortresses.html
---

<br>
<table border="0">
  <tbody>
    <tr>
      <td style="VERTICAL-ALIGN: top">
        I forget the first time I became aware of <a href="https://en.wikipedia.org/wiki/Roger_Sessions">Roger
        Sessions</a>. I think a collegue of mine in the .com days might have had him as a lecturer. Certainly I got on
        his <a href="http://www.objectwatch.com/">ObjectWatch</a> newsletter some time back.<br>
        <br>
        I picked up <strong>Software Fortresses</strong> - <em>Modeling Enterprise Architectures</em> from the library
        and it is an interesting read. While I don't see too much evidence that the methodology expoused by the book
        has been adopted by the mainstream, it is a book that is worth reading for some of the ideas none-the-less.<br>
        <br>
        Principle among these is the idea that system boundries should be seen in the context of organisational
        dynamics. In other words, if your organisation goes for a centralised database structure and that is unlikely
        to change in the near term, then it makes sense to model and build your systems that way. This is a great
        insight as far as I am concerned. It is too easy to be seduced by the idea that IT folk are hyper-rational
        geeks, and forget the reality that we are all just as human as the rest. Anyone who has tried to implement a
        system for real can attest to the fact that often it is the human factor that is the primary determinant of
        success.<br>
        <br>
        The last chapter ("Postlude") is worth the price of the book itself. Here it lists a series of <em>Top-10s</em>
        such as
        <ul>
          <li style="list-style: none">
            <br>
          </li>
          <li>Ten Important Points about Software Fortresses
          </li>
          <li style="list-style: none">
            <br>
          </li>
          <li>Ten Reasons to Adopt the Software Fortress Model
          </li>
          <li style="list-style: none">
            <br>
          </li>
          <li>Ten Rules for Software Fortress Design
          </li>
          <li style="list-style: none">
            <ul>
              <li style="list-style: none">
                <br>
              </li>
              <li>At the enterprise level, focus on treaties (between fortresses)
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Define fortresses with the right amount of granularity
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Look carefully at your walls (for security implications especailly)
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Look carefully at your guards
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Make sure nobody can exit the fortress except through an envoy
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Design infograms to be resilient
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Design your fortress to scale
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Use only losely coupled transations across fortresses
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Use tightly coupled transations only within the fortress
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Use asynchronous drawbridges wherever possible
              </li>
            </ul><br>
          </li>
          <li>Ten Controversial Ideas within the Sofftware Fortress Model
          </li>
          <li style="list-style: none">
            <ul>
              <li style="list-style: none">
                <br>
              </li>
              <li>Performance doesn't count (as much as the overall design)
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Put security only in the guard
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>
                <strong>Organisational boundaries are related to fortress boundaries</strong>
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Tightly coupled transactions shouldn't cross fortress boundaries
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>We need fortresses within fortresses
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software fortress model should always be used
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Turn off database security(!)
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Don't share databases across fortresses
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>Give scale-out priority to scale-up
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The model hasn;t been proven (but what has?)
              </li>
            </ul><br>
          </li>
          <li>Ten Considerations for Evaluating J2EE versus .NET
          </li>
          <li style="list-style: none">
            <br>
          </li>
          <li>Ten Observations on the State of the Software Industry
          </li>
          <li style="list-style: none">
            <ul>
              <li style="list-style: none">
                <br>
              </li>
              <li>The industry has no conceptual model for building enterprise systems
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry lacks a coherent vision for flowing transactions through the enterprise
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry has a confusing hodgepodge of security capabilities and no model for how they
              should be used
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry is wasting time defining portability standards when what we need are
              interoperability standards
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry does not differentiate among implementation technologies (such as objects),
              distribution technologies (such as components), and interoperability technologies (such as fortresses)
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry has no concept of the difference between the communications that must occur
              within a system and the communications that must occur between systems
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry does not have a common model for interoperability, so different vendors create
              products that are difficult to glue together
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry uses technology-specific terminology for describing what is being done, making
              it difficult to udnerstand when common approaches are being used (e.g. session beans v. COM+ components)
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry assumes that interoperability will be solved by the choice of one single
              technology that will integrate everything
              </li>
              <li style="list-style: none">
                <br>
              </li>
              <li>The software industry frequently provides capabilities that are not only not useful, but downright
              harmful (examples include entity beans, distrubuted objects, Microsofts Transation Internet Protocol)
              </li>
            </ul>
          </li>
        </ul><br>
        The book was published in 2003, but I think we see some sign that the challenges expresed by Mr sessions may
        well be being addressed - such as the wide-spread adoption of SOAP/Web Services. Mr Sessions words do however
        spell a warning to those who try to overload such technologies with too much intre-fortress baggage.<br>
      </td>
      <td style="VERTICAL-ALIGN: top">
        <iframe src=
        "https://rcm.amazon.com/e/cm?t=itsaprli-20&amp;o=1&amp;p=8&amp;l=as1&amp;asins=0321166086&amp;fc1=000000&amp;IS2=1&amp;lt1=_blank&amp;lc1=0000FF&amp;bc1=000000&amp;bg1=FFFFFF&amp;f=ifr"
        style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe><br>
      </td>
    </tr>
  </tbody>
</table>
